mod rasn {

    #[derive(Debug, PartialEq)]
    enum IdentifierType {
        Universal,
        Application,
        ContextSpecific,
        Private
    }

    #[derive(Debug, PartialEq)]
    enum SimpleType {
        Integer,
        BitString,
        OctetString,
        Null,
        ObjectIdentifier,
        Sequence,
        Set,
        PrintableString,
        T61String,
        IA5String,
        UTCTime,
        Unknown(u8)
    }

    #[derive(Debug, PartialEq)]
    struct Tag {
        id : IdentifierType,
        typ: SimpleType
    }

    #[derive(Debug, PartialEq)]
    struct TLV<'a> {
        tag: Tag,
        length: usize,
        value: &'a[u8]
    }

    #[derive(Debug, PartialEq)]
    struct ParseOk<'a, T> {
        value : T,
        remainder: &'a[u8]
    }

    #[derive(Debug, PartialEq)]
    enum ParseError<'a> {
        UnsupportedIdentifier(IdentifierType),
        InsufficientBytes(usize, &'a[u8]), // the required length and the actual remaining bytes
        UnsupportedLengthByteCount(u8),
        BadLengthEncoding(u8)
    }

    type ParseResult<'a, T> = Result<ParseOk<'a, T>, ParseError<'a>>;

    fn parse_ok<T>(value : T,  remainder: &[u8]) -> ParseResult<T> {
        Ok(ParseOk { value, remainder })
    }

    fn parse_tlv(input: &[u8]) -> ParseResult<TLV> {
        if input.len() < 2 {
            return Err(ParseError::InsufficientBytes(2, input))
        }

        let tag = Tag {id : get_identifier_type(input[0]), typ: get_simple_type(input[0])};

        return parse_length(&input[1..]).and_then(|result : ParseOk<usize>| {
            let remainder = &input[2..];
            if remainder.len() < result.value as usize {
                return Err(ParseError::InsufficientBytes(result.value, remainder))
            }

            let tlv = TLV {tag, length : result.value, value: &remainder[..result.value]};

            parse_ok(tlv, &remainder[result.value..])
        }
        );
    }

    fn get_identifier_type(value: u8) -> IdentifierType {
        match value & 0b11000000 {
            0b01000000 => IdentifierType::Application,
            0b10000000 => IdentifierType::ContextSpecific,
            0b11000000 => IdentifierType::Private,
            _ => IdentifierType::Universal
        }
    }

    fn get_simple_type(value: u8) -> SimpleType {
        let masked: u8 = value & 0b00111111;

        match masked {
           0x02 => SimpleType::Integer,
           0x03 => SimpleType::BitString,
           0x04 => SimpleType::OctetString,
           0x05 => SimpleType::Null,
           0x06 => SimpleType::ObjectIdentifier,
           0x30 => SimpleType::Sequence,
           0x31 => SimpleType::Set,
           0x13 => SimpleType::PrintableString,
           0x14 => SimpleType::T61String,
           0x16 => SimpleType::IA5String,
           0x17 => SimpleType::UTCTime,
           _ => SimpleType::Unknown(masked)
        }
    }

    fn parse_length(input: &[u8]) -> ParseResult<usize> {

        fn decode_one(input: &[u8]) -> ParseResult<usize> {
            let value = input[0];
            if value < 128 {
                Err(ParseError::BadLengthEncoding(value)) // should have been encoded in single byte
            } else {
                parse_ok(value as usize, &input[1..])
            }
        }

        fn decode_two(input: &[u8]) -> ParseResult<usize> {
           let value = (input[0] as usize) << 8 | input[1] as usize;
           parse_ok(value, &input[2..])
        }

        fn decode_three(input: &[u8]) -> ParseResult<usize> {
            let value = ((input[0] as usize) << 16) | ((input[1] as usize) << 8) | (input[2] as usize);
            parse_ok(value, &input[3..])
        }

        fn decode_four(input: &[u8]) -> ParseResult<usize> {
            let value = ((input[0] as usize) << 24) | ((input[1] as usize) << 16) | ((input[2] as usize) << 8) | (input[3] as usize);
            parse_ok(value, &input[4..])
        }

        if input.len() < 1 {
            return Err(ParseError::InsufficientBytes(1, input))
        }

        let top = input[0] & 0b10000000;
        let count = input[0] & 0b01111111;

        if top == 0 {
            parse_ok(count as usize, &input[1..])
        }
        else {

            let remainder = &input[1..];

            if remainder.len() < count as usize {
                return Err(ParseError::InsufficientBytes(count as usize, remainder))
            }

            match count {
                1 => decode_one(remainder),
                2 => decode_two(remainder),
                3 => decode_three(remainder),
                4 => decode_four(remainder),
                _ => Err(ParseError::UnsupportedLengthByteCount(count))
            }
        }
    }


    #[cfg(test)]
    mod tests {
        use ::rasn::*;

        const TOP_BIT : u8 = 1 << 7;

        const CERT_DATA : [u8; 534] = [
            0x30, 0x82, 0x02, 0x12, 0x30, 0x82, 0x01, 0x7b, 0x02, 0x02, 0x0d, 0xfa, 0x30, 0x0d, 0x06, 0x09,
            0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x81, 0x9b, 0x31, 0x0b,
            0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x4a, 0x50, 0x31, 0x0e, 0x30, 0x0c, 0x06,
            0x03, 0x55, 0x04, 0x08, 0x13, 0x05, 0x54, 0x6f, 0x6b, 0x79, 0x6f, 0x31, 0x10, 0x30, 0x0e, 0x06,
            0x03, 0x55, 0x04, 0x07, 0x13, 0x07, 0x43, 0x68, 0x75, 0x6f, 0x2d, 0x6b, 0x75, 0x31, 0x11, 0x30,
            0x0f, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x08, 0x46, 0x72, 0x61, 0x6e, 0x6b, 0x34, 0x44, 0x44,
            0x31, 0x18, 0x30, 0x16, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x0f, 0x57, 0x65, 0x62, 0x43, 0x65,
            0x72, 0x74, 0x20, 0x53, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x31, 0x18, 0x30, 0x16, 0x06, 0x03,
            0x55, 0x04, 0x03, 0x13, 0x0f, 0x46, 0x72, 0x61, 0x6e, 0x6b, 0x34, 0x44, 0x44, 0x20, 0x57, 0x65,
            0x62, 0x20, 0x43, 0x41, 0x31, 0x23, 0x30, 0x21, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,
            0x01, 0x09, 0x01, 0x16, 0x14, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x40, 0x66, 0x72, 0x61,
            0x6e, 0x6b, 0x34, 0x64, 0x64, 0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x1e, 0x17, 0x0d, 0x31, 0x32, 0x30,
            0x38, 0x32, 0x32, 0x30, 0x35, 0x32, 0x36, 0x35, 0x34, 0x5a, 0x17, 0x0d, 0x31, 0x37, 0x30, 0x38,
            0x32, 0x31, 0x30, 0x35, 0x32, 0x36, 0x35, 0x34, 0x5a, 0x30, 0x4a, 0x31, 0x0b, 0x30, 0x09, 0x06,
            0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x4a, 0x50, 0x31, 0x0e, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x04,
            0x08, 0x0c, 0x05, 0x54, 0x6f, 0x6b, 0x79, 0x6f, 0x31, 0x11, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x04,
            0x0a, 0x0c, 0x08, 0x46, 0x72, 0x61, 0x6e, 0x6b, 0x34, 0x44, 0x44, 0x31, 0x18, 0x30, 0x16, 0x06,
            0x03, 0x55, 0x04, 0x03, 0x0c, 0x0f, 0x77, 0x77, 0x77, 0x2e, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c,
            0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x5c, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,
            0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x4b, 0x00, 0x30, 0x48, 0x02, 0x41, 0x00, 0x9b, 0xfc,
            0x66, 0x90, 0x79, 0x84, 0x42, 0xbb, 0xab, 0x13, 0xfd, 0x2b, 0x7b, 0xf8, 0xde, 0x15, 0x12, 0xe5,
            0xf1, 0x93, 0xe3, 0x06, 0x8a, 0x7b, 0xb8, 0xb1, 0xe1, 0x9e, 0x26, 0xbb, 0x95, 0x01, 0xbf, 0xe7,
            0x30, 0xed, 0x64, 0x85, 0x02, 0xdd, 0x15, 0x69, 0xa8, 0x34, 0xb0, 0x06, 0xec, 0x3f, 0x35, 0x3c,
            0x1e, 0x1b, 0x2b, 0x8f, 0xfa, 0x8f, 0x00, 0x1b, 0xdf, 0x07, 0xc6, 0xac, 0x53, 0x07, 0x02, 0x03,
            0x01, 0x00, 0x01, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05,
            0x05, 0x00, 0x03, 0x81, 0x81, 0x00, 0x14, 0xb6, 0x4c, 0xbb, 0x81, 0x79, 0x33, 0xe6, 0x71, 0xa4,
            0xda, 0x51, 0x6f, 0xcb, 0x08, 0x1d, 0x8d, 0x60, 0xec, 0xbc, 0x18, 0xc7, 0x73, 0x47, 0x59, 0xb1,
            0xf2, 0x20, 0x48, 0xbb, 0x61, 0xfa, 0xfc, 0x4d, 0xad, 0x89, 0x8d, 0xd1, 0x21, 0xeb, 0xd5, 0xd8,
            0xe5, 0xba, 0xd6, 0xa6, 0x36, 0xfd, 0x74, 0x50, 0x83, 0xb6, 0x0f, 0xc7, 0x1d, 0xdf, 0x7d, 0xe5,
            0x2e, 0x81, 0x7f, 0x45, 0xe0, 0x9f, 0xe2, 0x3e, 0x79, 0xee, 0xd7, 0x30, 0x31, 0xc7, 0x20, 0x72,
            0xd9, 0x58, 0x2e, 0x2a, 0xfe, 0x12, 0x5a, 0x34, 0x45, 0xa1, 0x19, 0x08, 0x7c, 0x89, 0x47, 0x5f,
            0x4a, 0x95, 0xbe, 0x23, 0x21, 0x4a, 0x53, 0x72, 0xda, 0x2a, 0x05, 0x2f, 0x2e, 0xc9, 0x70, 0xf6,
            0x5b, 0xfa, 0xfd, 0xdf, 0xb4, 0x31, 0xb2, 0xc1, 0x4a, 0x9c, 0x06, 0x25, 0x43, 0xa1, 0xe6, 0xb4,
            0x1e, 0x7f, 0x86, 0x9b, 0x16, 0x40
        ];

        #[test]
        fn get_identifier_type_decodes_correctly() {
            assert_eq!(get_identifier_type(1 << 6), IdentifierType::Application);
            assert_eq!(get_identifier_type(1 << 7), IdentifierType::ContextSpecific);
            assert_eq!(get_identifier_type(0xFF), IdentifierType::Private);
            assert_eq!(get_identifier_type(3), IdentifierType::Universal);
        }

        #[test]
        fn get_simple_type_decodes_correctly() {
            assert_eq!(get_simple_type(0x02), SimpleType::Integer);
            assert_eq!(get_simple_type(0x03), SimpleType::BitString);
            assert_eq!(get_simple_type(0xFF), SimpleType::Unknown(0x3F));
        }

        #[test]
        fn decode_length_on_empty_bytes_fails() {
            assert_eq!(parse_length(&[]), Err(ParseError::InsufficientBytes(1, &[])))
        }

        #[test]
        fn decode_length_on_single_byte_returns_valid_result() {
            assert_eq!(parse_length(&[127, 0xDE, 0xAD]), parse_ok(127, &[0xDE, 0xAD]))
        }

        #[test]
        fn decode_length_on_count_of_one_returns_none_if_value_less_than_128() {
            assert_eq!(parse_length(&[TOP_BIT | 1, 127]), Err(ParseError::BadLengthEncoding(127)))
        }

        #[test]
        fn decode_length_on_count_of_one_succeeds_if_value_greater_than_127() {
            assert_eq!(parse_length(&[TOP_BIT | 1, 128]), parse_ok(128, &[]))
        }

        #[test]
        fn decode_length_on_count_of_two_succeeds() {
            assert_eq!(parse_length(&[TOP_BIT | 2, 0x01, 0x02, 0x03]), parse_ok(0x0102, &[0x03]))
        }

        #[test]
        fn decode_length_on_count_of_three_succeeds() {
            assert_eq!(parse_length(&[TOP_BIT | 3, 0x01, 0x02, 0x03, 0x04]), parse_ok(0x010203, &[0x04]))
        }

        #[test]
        fn decode_length_on_count_of_four_succeeds() {
            assert_eq!(parse_length(&[TOP_BIT | 4, 0x01, 0x02, 0x03, 0x04, 0x05]), parse_ok(0x01020304, &[0x05]))
        }

        #[test]
        fn decode_length_on_count_of_five_fails() {
            assert_eq!(parse_length(&[TOP_BIT | 5, 0x01, 0x02, 0x03, 0x04, 0x05]), Err(ParseError::UnsupportedLengthByteCount(5)))
        }


    }
}




